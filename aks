#! /usr/bin/env python

import rospy

from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Point, Twist
from nav_msgs.msg import Odometry 
from tf.transformations import euler_from_quaternion
from math import atan2

pub = None
x=0.0
y=0.0
theta=0.0


def newOdom(msg):
    global x
    global y
    global theta
    
    x=msg.pose.pose.position.x
    y=msg.pose.pose.position.y
    
    rot_q=msg.pose.pose.orientation
    (roll, pitch, theta)=euler_from_quaternion([rot_q.x, rot_q.y, rot_q.z, rot_q.w]) 
    







def callback_laser(msg):
  # 120 degrees into 3 regions
  regions = {
    'right':  min(min(msg.ranges[0:2]), 10),
    'front':  min(min(msg.ranges[3:5]), 10),
    'left':   min(min(msg.ranges[6:9]), 10),
  }
  
  take_action(regions)
  
def take_action(regions):
  goal=Point()
  goal.x=3
  goal.y=6
  linear_speed = 0.6
  angular_speed = 1
  threshold_dist = 1.5
  inc_x=goal.x-x
  inc_y=goal.y-y
  msg = Twist()
  linear_x = 0
  angular_z = 0
  speed=Twist()
  angle_to_goal=atan2(inc_y, inc_x)
  if abs(angle_to_goal-theta)>0.1:
           speed.linear.x=0.0
           speed.angular.z=0.3
           
  
           if regions['front'] > threshold_dist and regions['left'] > threshold_dist and regions['right'] > threshold_dist:
             speed.linear.x = linear_speed
             speed.angular.z = 0
    
           elif regions['front'] < threshold_dist and regions['left'] < threshold_dist and regions['right'] < threshold_dist:

             speed.linear.x = -linear_speed
             speed.angular.z = angular_speed # Increase this angular speed for avoiding obstacle faster
   
           elif regions['front'] < threshold_dist and regions['left'] > threshold_dist and regions['right'] > threshold_dist:
              
             speed.linear.x = 0
             speed.angular.z = angular_speed
   
           elif regions['front'] > threshold_dist and regions['left'] > threshold_dist and regions['right'] < threshold_dist:
              
             speed.linear.x = 0
             speed.angular.z = -angular_speed
  
           elif regions['front'] > threshold_dist and regions['left'] < threshold_dist and regions['right'] > threshold_dist:
              
             speed.linear.x = 0
             speed.angular.z = angular_speed
   
           elif regions['front'] < threshold_dist and regions['left'] > threshold_dist and regions['right'] < threshold_dist:
              
             speed.linear.x = 0
             speed.angular.z = -angular_speed
    
           elif regions['front'] < threshold_dist and regions['left'] < threshold_dist and regions['right'] > threshold_dist:
             
             speed.linear.x = 0
             speed.angular.z = angular_speed
    
           elif regions['front'] > threshold_dist and regions['left'] < threshold_dist and regions['right'] < threshold_dist:
             
             speed.linear.x = linear_speed
             speed.angular.z = 0
   
           else:
             state_description = 'unknown case'
             rospy.loginfo(regions)

  else:
           speed.linear.x=0.5
           speed.angular.z=0.0
            
  
           if regions['front'] > threshold_dist and regions['left'] > threshold_dist and regions['right'] > threshold_dist:
              
             speed.linear.x = linear_speed
             speed.angular.z = 0
    
           elif regions['front'] < threshold_dist and regions['left'] < threshold_dist and regions['right'] < threshold_dist:
              
             speed.linear.x = -linear_speed
             speed.angular.z = angular_speed # Increase this angular speed for avoiding obstacle faster
   
           elif regions['front'] < threshold_dist and regions['left'] > threshold_dist and regions['right'] > threshold_dist:
              
             speed.linear.x = 0
             speed.angular.z = angular_speed
   
           elif regions['front'] > threshold_dist and regions['left'] > threshold_dist and regions['right'] < threshold_dist:
              
             speed.linear.x = 0
             speed.angular.z = -angular_speed
  
           elif regions['front'] > threshold_dist and regions['left'] < threshold_dist and regions['right'] > threshold_dist:
              
             speed.linear.x = 0
             speed.angular.z = angular_speed
   
           elif regions['front'] < threshold_dist and regions['left'] > threshold_dist and regions['right'] < threshold_dist:
             
             speed.linear.x = 0
             speed.angular.z = -angular_speed
    
           elif regions['front'] < threshold_dist and regions['left'] < threshold_dist and regions['right'] > threshold_dist:
              
             speed.linear.x = 0
             speed.angular.z = angular_speed
    
           elif regions['front'] > threshold_dist and regions['left'] < threshold_dist and regions['right'] < threshold_dist:
              
             speed.linear.x = linear_speed
             speed.angular.z = 0
   
           else:
              
             rospy.loginfo(regions)
  
 


  
  
  pub.publish(speed)
  
  

def main():
  global pub
  
  rospy.init_node('reading_laser')
  
  pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
  
  sub = rospy.Subscriber('/robot/laser/scan', LaserScan, callback_laser)
  
  sub=rospy.Subscriber('/odometry/filtered', Odometry, newOdom)
  
  rospy.spin()

if __name__ == '__main__':
  main()
